------------------------------------- v3.1 ------------------------------------------
1. 加上拨码开关，用PA5|PA6|PA7   ---需要在MCUInit中开启相关引脚的输入功能
2. 方案1 --- 0010 ---- 主要提高过弯刹车速度极限，直道速度
   方案2 --- 0100 ---- 弯道速度不测速回馈控制
   方案3 --- 0000 ---- 3.0原版                         ----2010.7.19

3. 位1控制curve_pulse
   位2控制speed_*(PWM)
   位3控制*_pulse_max
                              
4. 需要修改为 DDRA = 0B00011111
5. 增加PE3来接受拨码开关4，用来控制弯道回正后刹车减速
6. 去掉计算舵机转角函数中的last_status参数（没用到）
7. 发现逻辑错误，*_pulse_max在预定义中没有按从大到小排序
                                            
                                                  ----2010.7.20                                        
                                                           


------------------------------------- v3.0 ------------------------------------------
1. 继续检查/裁剪代码，以减少逻辑错误，或多余语句。。
	实际操作---1 删除scheme库
                   2 删除道路类型枚举类型、速度状态枚举类型、小车舵机方向枚举类型，小车相对黑线位置枚举类型
                   3 删除获取道路类型函数（空）
                   4 删除保存位置函数（空）
                   5 删除保存速度函数（空）
                   6 删除全速控制函数（空） 
2. 回归测试之添加“弯道连续照空后加速”
3. 非超速的速度PD控制去掉“if(速度没有达到上限) pwm=设定值”的语句   ----失败，电机转动出现错误，齿轮卡
4. 仔细检查代码逻辑错误
5. 把此版本定为最终版本
6. 稳定跑参数 ---电池7.5V  前瞻35cm   光斑宽度27.8cm

                                                                                       ---- 2010.7.17

------------------------------------- v2.9 ------------------------------------------
1. 开始检查/裁剪代码，以减少逻辑错误，或多于语句。。
2. 继续优化参数   实际调整情况为 ----1.舵机左右极限和舵机转角离散值 2.用来判断直道的连续照到中间值的次数调整为50  
3. 添加拐弯回正刹车减速策略        ----结论：转弯有上下抖动现象
4. 每个速度状态都对其PD稳定控制,P、D参数各不相同,暂时都为P--4, D--5
5. 研究刹车效果
6. 去除“预防转弯过调”策略    ----结论：无明显差异
7. 尝试直道的定义改为“50次采集到中间值后”  ----效果明显（弯道不会检测到直线，从而不会加速，导致弯度速度不稳定）
8. 初步将此版本定为最终版本



                                                               ---- 2010.7.17
------------------------------------- v2.8、v2.8_steerTest ------------------------------------------
1. 调试改造后的舵机，确认其参数
2. 尝试采用连续照到10次空.加速策略，然后再让其减速，以应对过弯回正过程减速不下来。。。
   此加速策略与直道加速策略并行运算，使用同一个加速/减速信号量
   第一个版本有个逻辑错误，把outside_count和inside_count搞错了，判断的时候==和<搞错了，判断反了
3. 传感器前瞻30CM,照的间隔为1.29MS
4. 找到刹车不明显原因----PWM45输出频率才50HZ，改成8KHZ
5. 增加直道匀速算法。。稳定在2m/s
6. 弯道加速策略不好用，判断不精确
7. 基本可以稳定跑参数，过急弯道有风险，弯道速度需降低


                                                               -----2010.7.16
------------------------------------- v2.7 ------------------------------------------
1. 发现判断直道条件太苛刻，在直道中也会有刹车现象，可以使判断范围离中间值再远点，
   abs(status - MID7) < 4    ---->    abs(status - MID7) < 9  -----有明显效果！！！
2. 发现逻辑错误
  int delta = PWMDTY01 - turn_angle_PWM 改为 int delta = turn_angle_PWM - PWMDTY01
  if(abs_delta >= ANGLE_DELTA) PWMDTY01 += ANGLE_DELTA;
  改为      if(abs_delta >= ANGLE_DELTA) {
                if(delta > 0)
                  PWMDTY01 += ANGLE_DELTA;
                else
                  PWMDTY01 -= ANGLE_DELTA;
            } 
   转角调整有效果！！！ 
3. 同时还需调整ANGLE_DELTA，当前为100,改为140后效果不明显
4. 可以稳定跑，参数为---
    ANGLE_DELTA 100
    #define PWM1_MID 1550   //舵机中间
    #define PWM1_MAXR 2300  //舵机最右
    #define PWM1_MAXL 800   //舵机最左
    #define PWM3_SLOW 55   //速度慢  ( 电压 = 2.88v)
    #define PWM3_FAST 60    //速度快  ( 电压 = 3.67v )
    #define PWM3_NORMAL 58 //速度正常 ( 电压 = 3.2v )
    #define PWM3_SUPER_FAST 86  //直道速度  ( 电压 = 5v )
    #define PWM5_BREAK 180   //反向刹车速度 
    #define CURVE_PULSE 65   //入弯脉冲数极限值
    #define INSIDE_COUNT_MAX 10 //连续直道计数 

5. 调整传感器前瞻为38CM左右，照射时间为1.45MS

                                                   
                                                   
                                                    ---------2010.7.15
------------------------------------- v2.6 ------------------------------------------
1.ANGLE_DELTA越大，过连续小S弯道越平滑，但转向越不足，小半径圆过不去
2.加强长直道判别，范围更小
3.可以稳定跑，只要调节相关速度值 

                                                   ---------2010.7.14
------------------------------------- v2.5 ------------------------------------------
1. 保存实时信息到Data_Flash,断电后用串口发送
2. 传感器重新调整后宽度为29~~30CM  ，前瞻为32cm--34cm
3. 尝试消除转弯过调策略1（若上次为左空/右空，而这次不是左空/右空，这次舵机值为中间值）
       消除转弯过调策略2（若上几次中有出现左空/右空，而这次的从边界起倒数第3个亮或倒数2,3个亮，这次舵机值为中间值）---信号量机制（加锁/解锁）
4. 记录激光管每个状态舵机转角，并分析
   边缘空 ------750 --> 770      0   0   0   0   0   0   0   |0|   0   0   0   0   0   0   0
   边缘0  ------600 --> 680      *   0   0   0   0   0   0   |0|   0   0   0   0   0   0   0
   边缘01 ------500 --> 580      *   *   0   0   0   0   0   |0|   0   0   0   0   0   0   0
   边缘1  ------350 --> 480      0   *   0   0   0   0   0   |0|   0   0   0   0   0   0   0
   边缘12 ------300 --> 370      0   *   *   0   0   0   0   |0|   0   0   0   0   0   0   0
   边缘2  ------260 --> 280      0   0   *   0   0   0   0   |0|   0   0   0   0   0   0   0
   边缘23 ------210 --> 230      0   0   *   *   0   0   0   |0|   0   0   0   0   0   0   0
   边缘3  ------180 --> 190      0   0   0   *   0   0   0   |0|   0   0   0   0   0   0   0
   边缘34 ------150 --> 155      0   0   0   *   *   0   0   |0|   0   0   0   0   0   0   0
   边缘4  ------130 --> 120      0   0   0   0   *   0   0   |0|   0   0   0   0   0   0   0
   边缘45 ------110 --> 90       0   0   0   0   *   *   0   |0|   0   0   0   0   0   0   0
   边缘5  ------90  --> 70       0   0   0   0   0   *   0   |0|   0   0   0   0   0   0   0
   边缘56 ------70  --> 60       0   0   0   0   0   *   *   |0|   0   0   0   0   0   0   0
   边缘6  ------50  --> 50       0   0   0   0   0   0   *   |0|   0   0   0   0   0   0   0
   边缘67 ------30  --> 20       0   0   0   0   0   0   *   |*|   0   0   0   0   0   0   0
   
   0   1   2   3   4   5   6   |7|   8   9  10  11  12  13  14  
                               | |
   0   0   0   0   0   0   0   |0|   0   0   0   0   0   0   0
                               | |
   *   *   *   *   *   *   *   |*|   *   *   *   *   *   *   * 

5.删除PID控制库
6.问题：直道直行会向左偏，尝试左极限790，右极限2330，中值1560
7.加上小车相对黑线位置枚举变量CAR_POSITION,消除转弯果条策略2中使用
8.加上直道入弯判别和弯道进直道判别，用10组连续的激光管采样，若偏差一直不为空，则在直道，反之只要有1组出现空，且计数器还没达到10，则计数器清零，重新计数，默认计数器值为10，即在直道中

9.可以稳定跑，只要调节相应速度值----传感器前瞻28CM

                                                                      ------2010.7.13

------------------------------------- v2.4 ------------------------------------------
1. 判断激光管状态函数中增加消除不连续状态算法（取前后两次的平均值,误判严重）
2. 尝试ANGLE_DELTA 改成300 ，传感器接收周期为170（1.7ms）
3. 稳定跑参数
    传感器---前瞻32.5cm,宽度28cm
    ANGLE_DELTA  140
    激光管采集周期170
    舵机转角离散值和上次一样
    
    #define PWM3_SLOW 43    //速度慢 （2.5112v） 
    #define PWM3_FAST 66    //速度快 （3.8544v）
    #define PWM3_NORMAL 54  //速度正常 （3.1536v）
                                                                    ------2010.7.12
------------------------------------- v2.3 ------------------------------------------
1. 增加测速和反转调速模块
2. 需模拟蓝色赛道背景
3. 激光管有可能内部电容过大（尽量减少激光管照射周期）
                                                                    ------2010.7.11

------------------------------------- v2.2 ------------------------------------------
1. 修改舵机转角常量，使其亮的值与激光管数组一一对应
2. 需要确定是否保证每个激光管状态都有可能出现（主要排除激光管排列距离过大或过小）
3. 判断激光管状态函数可以更简洁，在确定好status后，再加一个判断if（abs(lase_status-status)>2）status=last_status（失败，弯道接收信息会不连续+加上花色地板随机信息干扰）
4. 重新改回15个完整的激光管
5. ANGLE_DELTA 改成100 转弯效果好点
6. 决定滤波不考虑花色背景
7. 需要用串口测试坡道，十字线，起始线的传感器状态特征

                                                                  -----2010.7.10

------------------------------------- v2.1 ------------------------------------------
1. 屏蔽最左边坏掉的激光管
2. 重新调整所有左转离散值 和 正常转动离散值
3. 增加赛道边缘错误信息的滤波算法(失败：舵机不转 ----误判)
4. 利用上次状态增加激光管状态判断的准确性
5. 可以跑参数
   激光管照射时间 ---- 600
   舵机每次递增的值ANGLE_DELTA ----30
   舵机每个传感器状态对应的转角值 ---- int micro_delta0 = 30;  //微调0
                                       int micro_delta1 = 50;  //微调1
                                       int micro_delta2 = 70;  //微调2
  				       int micro_delta3 = 90;  //微调3
  				       int micro_delta4 = 110; //微调4
                                       int micro_delta5 = 130; //微调5
  
                                       int mid_delta0 = 150; //中调0
                                       int mid_delta1 = 180; //中调1
                                       int mid_delta2 = 210; //中调2
                                       int mid_delta3 = 260; //中调3
                                       int mid_delta4 = 300; //中调4
  
                                       int large_delta0 = 350; //大调0
                                       int large_delta1 = 500; //大调1
                                       int large_delta2 = 600; //大调2
                                       int large_delta3 = 750; //大调3
  
                                 //============================================
                                       int left_micro_delta0 = 30;  //左微调0
                                       int left_micro_delta1 = 50;  //左微调1
                                       int left_micro_delta2 = 70;  //左微调2
                                       int left_micro_delta3 = 90;  //左微调3
                                       int left_micro_delta4 = 110; //左微调4
  
                                       int left_mid_delta0 = 140; //左中调0
                                       int left_mid_delta1 = 180; //左中调1
                                       int left_mid_delta2 = 220; //左中调2
                                       int left_mid_delta3 = 260; //左中调3
                                       int left_mid_delta4 = 320; //左中调4
  
                                       int left_large_delta0 = 400; //左大调0
                                       int left_large_delta1 = 570; //左大调1
                                       int left_large_delta2 = 750; //左大调2

                                                                             ---------2010.7.9
-------------------------------------------- v2.0 ------------------------------------------
1. 传感器方案改用15个激光管
2. 找出逻辑错误---计算激光管状态函数，if里的判断增强，修改为“if(某个中间值为1，且两边都不为1)”;与运算少写一个“&”
3. 保留赛道边缘干扰屏蔽,并增加判断，把上次所有左边/右边状态都包括，不止左空/右空;把错误干扰状态直接改成左空/右空，而不是last_status
  else if (temp_laser_array[6] == 1 & temp_laser_array[7] == 1) {
      if(last_status == LEFT_NONE)
          status = last_status;
      else
          status = RIGHT34;
  }
  else if (temp_laser_array[0] == 1 & temp_laser_array[1] == 1) {
      if(last_status == RIGHT_NONE)
          status = last_status;
      else
          status = LEFT34;
  }
  else if (temp_laser_array[7] == 1) {
      if(last_status == LEFT_NONE)
          status = last_status;
      else
          status = RIGHT4;
  }
  else if (temp_laser_array[0] == 1) {
      if(last_status == RIGHT_NONE)
          status = last_status;
      else
          status = LEFT4; 
  }
    
4.尝试舵机调整参数为                     速度调整档为
  int micro_delta0 = 40;  //微调0           <=150    慢
  int micro_delta1 = 60;  //微调1           >=350    快
  int micro_delta2 = 80;  //微调2           150~~350 中
  int micro_delta3 = 100; //微调3
  int micro_delta4 = 130; //微调4
  int micro_delta5 = 160; //微调5
  
  int mid_delta0 = 190; //中调0
  int mid_delta1 = 230; //中调1
  int mid_delta2 = 270; //中调2
  int mid_delta3 = 310; //中调3
  int mid_delta4 = 350; //中调4
  
  int large_delta0 = 400; //大调0
  int large_delta1 = 550; //大调1
  int large_delta2 = 650; //大调2
  int large_delta3 = 750; //大调3 
                                                    ---2010.7.8

------------------------------------- v1.9 ------------------------------------------
1. 分析串口发送的传感器实时状态数据
2. 当传感器状态发生变化时，打印改变标志“====”
3. 在main函数中删除SaveLaser()的语句调用 和 last_laser_array变量，因为没有利用上次激光数组
4. 激光管用PIT分时点亮缺陷 ---- 最后一组亮的激光管亮的时间会较长，因为中间屏蔽了中断，且增加了处理信息的时间

                                                                    ---2010.7.8


------------------------------------- v1.8 ------------------------------------------
1. 要让激光管状态跟上次比较，从而决定舵机要转的角度
2. 要判断进弯，出弯，直道等
3. 增加测试辅助库testingAuxiliary.h，用来串口实时发送激光管采集数组信息和激光管状态到PC，包装成一个函数
4. 尝试修改激光管方式为1次点亮4个，用2次就可全部接收道路信息(不成功，需延长激光管照射时间)
5. 激光管照射时间改为200
6. 调试经验：激光管照射功率不足会接收不到正确道路信息。
7. 问题：电池充满时，电机PWM输出电压比理论值大
   
                                                                    ---2010.7.7

------------------------------------- v1.7 ------------------------------------------
1. 进入特殊路标时增加标志位，出特殊路标后清零 
2. 判断起始线找特殊“01串”----0110、0010、0100、00100
3. 需解决问题  ----直道加速、直道舵机转角减少
               ----让激光管状态跟上次比较，从而决定舵机要转的角度
  
5. 初步去除赛道背景干扰，只判断最两边的2个激光管亮异常 
6. 经过起始线后StopCar()函数修正，（1.停止车标记置位， 2.延时一段时间后，让之后的PWMDTY23等于1） 
7. 找出逻辑错误，修改为if(last_usualRoad_flag == TRUE)                                    
                                                                        ---2010.7.4

------------------------------------- v1.6 ------------------------------------------
1. 初始速度为中，直道（转角<=100）为快，弯道（转角>=300）为慢，中间情况为中;减速或加速时绿色LED灯亮
2. 需调试部分  -----速度增加或减少的延迟时间
3. 小车成功跑参数 ----舵机转角依次为40,70,90,120,150,200,300,700
                  ----速度依次为43（2.52v）,58（3.4v）,66（3.9v）
                  ----舵机转角增加量ANGLE_DELTA = 20
                  ----舵机PWM左中右依次为：800,1550,2300  
4.问题：不能判断起始线；拐弯超调                                                                                                                                                      ---2010.7.3


------------------------------------ v1.5 -----------------------------------------
1. cpp代码量限定为1024 bytes,全部改成.c文件，解决此问题
2. PIT0中断控制激光传感器分时亮
3. 去除部分冗余文件（ISR.h,ISR.cpp 和 EnDisInt.h）
4. 重新确定舵机左右极限和正中值
5. 直道可以正常跑，弯道须减速和提前拐弯

6. 需调试部分-------P参数
             -------激光管每个状态舵机具体转角
7. 待解决问题-----智能车初始化延时加长，消除电机初始化时电压满格状态
             
                                                 ---2010.7.2

------------------------------------- v1.4 ------------------------------------------
待解决功能：
1. 延迟2秒后，电机正转功能使能
2. 舵机Pd算法
3. 激光传感器中断实时采集
                            ---2010.6.26


------------------------------------- v1.3 --------------------------------------------
1. 规范变量名和函数名：变量名以小写开头，下划线连接；函数名以大写开头，无下划线并驼峰标识

2. 记录小范围次数的整数一律采用byte型

3. 添加了  1.计算激光管亮起个数的函数、2.计算遇到起始线次数的函数

4. 主函数流程为：1.智能车隐性状态（控制变量等）初始化 
                 2.机械（MCU）初始化 
                 3.智能车显性状态初始化
                 4.获取激光管数据
                 5.先判断是否特殊路况：
                 （若是，判断是否为起始线：
                        （若是，计算起始线次数：
                         若起始线次数为1，正常；为2，过起始线后停止
                        （若不是，可能为十字线）
                 （若不是，获取车头相对黑线偏移量---》做保存工作）

                 6.按常规控制舵机转向

5. 激光分时点亮，保存在temp_laser_array[]中

6. 问题：1 如何利用PIT模块延时
         2 c++代码量限制
         3 舵机需要添加PID算法
                                ---- 2010.6.23



------------------------------------------ v1.2 -------------------------------------------
1. 始终初始化程序代码修改，但总线时钟仍然为16M

2. 增加激光管状态转换函数，返回枚举类型，包括激光管所有状态

3. 舵机左极限、右极限、中值确定  
                                    ---2010.6.15



------------------------------------------ v1.1 ------------------------------------------------
1. 分离smartcarCtrl库中的PIDCtrl库  ---2010.5.20




------------------------------------------ v1.0 ---------------------------------------------------
1. 支持浮点型数据

2. 加入枚举常量，从而消除魔数
      1.小车相对黑线位置 
      2.道路类型
      3.小车速度状态
      4.小车舵机方向状态

3. 修改部分函数名称，使之见名知意

